El objetivo o funci√≥n de get_next_line() es leer una l√≠nea completa desde un descriptor de archivo, devolviendo esa l√≠nea como una cadena o string. Se lee desde un archivo o entrada est√°ndar (par√°metro de entrada), devuelve una sola l√≠nea cada vez que se le llama (√∫til para procesas archivos de texto) y, si la funci√≥n se llama de nuevo, contin√∫a leyendo desde donde se qued√≥ sin perder datos. Adem√°s, respeta buffers internos y no desperdicia memoria.

La funci√≥n get_next_line necesita: 
‚úÖ Leer bloques de datos (normalmente con read).
‚úÖ Acumular esos datos hasta formar una l√≠nea completa.
‚úÖ Detectar el salto de l√≠nea (\n) para saber cu√°ndo devolver una l√≠nea.
‚úÖ Conservar lo que sobra (si lees m√°s de una l√≠nea) para la siguiente llamada.

Funciones auxiliares necesarias para get_next_line
1Ô∏è‚É£ ft_strchr: Buscar un \n dentro de un string
    ‚Ä¢ Esta funci√≥n es clave porque necesitamos saber si ya hemos le√≠do una l√≠nea completa.
    ‚Ä¢ Cada vez que leemos un bloque de datos, comprobamos si dentro de ese bloque hay un salto de l√≠nea (\n).
    ‚Ä¢ Si lo encontramos, significa que tenemos una l√≠nea lista para devolver.
    ‚Ä¢ Sin esta funci√≥n, get_next_line no sabr√≠a cu√°ndo detenerse.

2Ô∏è‚É£ ft_strjoin: Unir strings (concatenar)
    ‚Ä¢ En cada llamada a read(), obtenemos un nuevo bloque de texto.
    ‚Ä¢ Necesitamos acumularlo junto con lo que ya hab√≠amos le√≠do antes (si es que a√∫n no tenemos una l√≠nea completa).
    ‚Ä¢ Esta funci√≥n nos permite juntar el "buffer acumulado" con lo nuevo que acabamos de leer.

3Ô∏è‚É£ ft_strdup: Crear una copia de un string
    ‚Ä¢ Cuando devolvemos una l√≠nea, es necesario copiar solo esa l√≠nea y almacenarla en un nuevo string.
    ‚Ä¢ Tambi√©n se usa para copiar lo que sobra despu√©s de un \n, para tenerlo listo en la siguiente llamada a get_next_line.
    ‚Ä¢ As√≠ nos aseguramos de no perder datos.

4Ô∏è‚É£ ft_substr: Extraer una subcadena de un string
    ‚Ä¢ Despu√©s de encontrar un \n, tenemos un string completo como l√≠nea.
    ‚Ä¢ Pero el buffer puede contener m√°s datos despu√©s de esa l√≠nea.
    ‚Ä¢ Con ft_substr, podemos cortar la l√≠nea justo donde termina y guardar el resto para la siguiente llamada.

5Ô∏è‚É£ ft_strlen: Calcular la longitud de un string
    ‚Ä¢ Necesario para asignar memoria correctamente al crear copias, unir strings o extraer subcadenas.
    ‚Ä¢ Sin esta funci√≥n, no podr√≠amos reservar el tama√±o adecuado de cada nuevo string.

En resumen
Estas funciones forman la base t√©cnica que permite que get_next_line funcione correctamente. Sin ellas, ser√≠a imposible:
‚úÖ Detectar el final de cada l√≠nea (ft_strchr).
‚úÖ Acumular datos le√≠dos (ft_strjoin).
‚úÖ Preparar y devolver una l√≠nea completa (ft_strdup y ft_substr).
‚úÖ Calcular tama√±os al reservar memoria (ft_strlen).
Por eso, aunque get_next_line es una sola funci√≥n "grande", en realidad es como un peque√±o equipo de funciones que trabajan juntas para resolver el problema de leer archivos l√≠nea por l√≠nea de forma eficiente.

üîÑ 1. read_and_accumulate
¬øQu√© hace?
Esta funci√≥n se encarga de leer datos desde el archivo (con read) y de acumularlos en un buffer din√°mico. Este buffer es donde vamos guardando todo lo que hemos le√≠do hasta el momento, porque una l√≠nea puede venir dividida en varios read() si es muy larga.
Paso a paso:
    1. Prepara un buffer temporal (buffer_temporary) del tama√±o BUFFER_SIZE para cada lectura.
    2. Si el buffer es NULL (es la primera vez que se llama), crea un string vac√≠o para empezar.
    3. Entra en un bucle:
        ‚ó¶ Si todav√≠a no encontramos un \n, sigue leyendo.
        ‚ó¶ Cada read a√±ade datos al buffer_temporary, que se concatenan al buffer ya acumulado.
    4. Cuando encuentra un \n o cuando ya no hay nada m√°s para leer, sale del bucle.

Funciones auxiliares usadas:
‚úÖ ft_strdup: Para inicializar el buffer.
‚úÖ ft_strchr: Para ver si ya hay un salto de l√≠nea.
‚úÖ ft_strjoin: Para acumular lo le√≠do.

üí• Posibles errores manejados:
‚ùå Si malloc falla.
‚ùå Si read devuelve -1 (error de lectura).

‚úÇÔ∏è 2. extract_line
¬øQu√© hace?
Una vez que el buffer tiene al menos una l√≠nea completa, esta funci√≥n extrae esa l√≠nea.
Paso a paso:
    1. Busca el primer \n en el buffer.
    2. Calcula cu√°ntos caracteres forman la l√≠nea (desde el inicio hasta el \n, incluido).
    3. Extrae exactamente esa porci√≥n usando ft_substr.
    4. Devuelve la l√≠nea lista para ser utilizada por el programa principal.

Funciones auxiliares usadas:
‚úÖ ft_strchr: Para encontrar el \n.
‚úÖ ft_strlen: Por si no hay \n, para devolver lo que haya.
‚úÖ ft_substr: Para cortar justo la parte de la l√≠nea.

üì¶ 3. update_buffer
¬øQu√© hace?
Despu√©s de devolver la l√≠nea, el buffer todav√≠a puede tener datos sobrantes (lo que viene despu√©s del \n). Esta funci√≥n:
    ‚Ä¢ Elimina la l√≠nea ya entregada.
    ‚Ä¢ Deja solo lo que sobra, preparado para la pr√≥xima llamada a get_next_line.

Paso a paso:
    1. Busca el \n (donde termina la l√≠nea devuelta).
    2. Si hay datos despu√©s, crea un nuevo buffer solo con esos datos.
    3. Libera el buffer viejo.
    4. Devuelve el nuevo buffer actualizado.

Funciones auxiliares usadas:
‚úÖ ft_strchr: Para encontrar el \n.
‚úÖ ft_strlen: Para calcular cu√°nto sobra.
‚úÖ ft_substr: Para cortar justo la parte que sobra.

üöÄ 4. get_next_line
¬øQu√© hace?
Este es el coraz√≥n del programa. Es la funci√≥n principal que el usuario llama, y que coordina todo el flujo:
Paso a paso:
    1. Si el fd es inv√°lido o el BUFFER_SIZE es incorrecto, devuelve NULL.
    2. Llama a read_and_accumulate para leer y preparar el buffer.
    3. Si el buffer es NULL (por error o porque ya termin√≥ el archivo), devuelve NULL.
    4. Si el buffer est√° vac√≠o, libera y devuelve NULL (caso archivo vac√≠o o EOF).
    5. Extrae la primera l√≠nea completa (con extract_line).
    6. Actualiza el buffer para la siguiente llamada (con update_buffer).
    7. Si despu√©s de actualizar el buffer queda vac√≠o, lo libera (EOF alcanzado despu√©s de esta l√≠nea).

Funciones auxiliares usadas:
‚úÖ read_and_accumulate: Lee y acumula el texto.
‚úÖ extract_line: Extrae una l√≠nea lista para devolver.
‚úÖ update_buffer: Prepara el buffer para la pr√≥xima llamada.

Manejo de errores:
‚ùå Si read_and_accumulate falla, devuelve NULL.
‚ùå Si hay un malloc fallido en cualquier momento, limpia y sale.

üîó BUFFER_SIZE peque√±o = read() m√°s veces = m√°s lento.
üí® BUFFER_SIZE grande = read() menos veces = m√°s r√°pido.
‚ùóÔ∏è Pero no afecta la funcionalidad: get_next_line es robusto y seguir√° devolviendo cada l√≠nea correctamente, aunque el rendimiento se degrade con un BUFFER_SIZE demasiado peque√±o.

üîç Caso 1: BUFFER_SIZE = 9999
‚úÖ Funciona correctamente.
    ‚Ä¢ Lo √∫nico que cambia es que read() leer√° hasta 9999 bytes de una vez.
    ‚Ä¢ Si hay l√≠neas muy largas (o pocas l√≠neas muy separadas por \n), este tama√±o es eficiente porque se reduce la cantidad de read().
    ‚Ä¢ get_next_line no tiene un l√≠mite m√°ximo de BUFFER_SIZE, m√°s all√° de lo que el sistema operativo y read() permitan.

üîç Caso 2: BUFFER_SIZE = 1
‚úÖ Funciona correctamente, pero es muy ineficiente.
    ‚Ä¢ read() leer√° solo un byte cada vez.
    ‚Ä¢ Esto hace que para leer una l√≠nea completa haya much√≠simas llamadas a read() y muchas operaciones de copia y concatenaci√≥n.
    ‚Ä¢ Pero desde un punto de vista funcional, get_next_line sigue devolviendo cada l√≠nea correctamente.
    ‚Ä¢ Solo que ser√° extremadamente lento, sobre todo con archivos grandes o l√≠neas largas.

üîç Caso 3: BUFFER_SIZE = 10000000 (diez millones)
‚úÖ Funciona, pero puede ser peligroso.
    ‚Ä¢ El read() intentar√° leer 10 millones de bytes de golpe.
    ‚Ä¢ Si el archivo es m√°s peque√±o o hay poca RAM disponible, es posible que:
        ‚ó¶ El sistema operativo devuelva menos datos (esto es normal y get_next_line deber√≠a manejarlo bien).
        ‚ó¶ Pero si hay un problema de memoria (por ejemplo, malloc falla al reservar un buffer tan grande), get_next_line fallar√°.
    ‚Ä¢ Sin embargo, en condiciones normales, get_next_line est√° preparado para manejar cualquier tama√±o de buffer.
üóÉÔ∏è ¬øQu√© es un buffer?
Un buffer es un bloque de memoria (generalmente un array o string) que se usa para almacenar temporalmente datos. En el caso de get_next_line, el buffer es donde guardamos los datos le√≠dos del archivo, para luego procesarlos y devolver las l√≠neas.
Ejemplo pr√°ctico:
Imagina que est√°s llenando un vaso de agua desde un grifo. El vaso es el buffer. El agua que entra es lo que read() lee desde el archivo. Cuando el vaso est√° lleno, lo usas (procesas o devuelves la l√≠nea) y luego vuelves a llenarlo.

¬øPor qu√© usamos buffers?
‚úÖ Leer grandes bloques es m√°s eficiente que leer car√°cter por car√°cter.
‚úÖ Permite acumular datos hasta que tengamos una l√≠nea completa.

üí• ¬øQu√© es un leak de memoria?
Un leak de memoria (fuga de memoria) ocurre cuando reservas memoria con malloc, pero nunca la liberas con free. Esa memoria queda "perdida": el programa ya no puede acceder a ella, pero el sistema operativo a√∫n la tiene marcada como ocupada.

Ejemplo pr√°ctico:
Es como si alquilas un almac√©n, guardas cosas dentro, pero pierdes la llave. El almac√©n sigue ocupado, pero t√∫ ya no puedes entrar ni liberar ese espacio. Si haces esto muchas veces, te quedas sin almacenes disponibles (sin memoria libre).

En get_next_line, un leak ocurre si:
    ‚Ä¢ Reservas un buffer con malloc, pero te olvidas de hacer free.
    ‚Ä¢ Sales de la funci√≥n por alg√∫n error o condici√≥n especial, sin liberar lo que ya hab√≠as reservado.

üì¶ ¬øQu√© es malloc?
malloc significa "memory allocation", o sea, "asignaci√≥n de memoria".
Es una funci√≥n que reserva un bloque de memoria del tama√±o que le digas. Pero no lo inicializa: el contenido de la memoria es basura (bytes aleatorios que estaban ah√≠ antes).
size es el n√∫mero de bytes que quieres reservar.

üíß ¬øQu√© es calloc?
calloc significa "clear allocation", o sea, "asignaci√≥n limpia".
Hace lo mismo que malloc (reserva memoria), pero adem√°s pone todo a cero.
nmemb: n√∫mero de elementos.
size: tama√±o de cada elemento (en bytes).

üí£ Casos peligrosos (leaks y double free)
Caso	Ejemplo	Problema
Leak	Te olvidas de free()	Pierdes memoria
Double Free	Haces free() dos veces	Comportamiento indefinido
Use After Free	Accedes a memoria despu√©s de free()	Crash o datos corruptos


üì¶ ¬øQu√© es la memoria de un programa?
Cuando ejecutas un programa en C, el sistema operativo le asigna un espacio de memoria. Ese espacio est√° dividido en varias zonas, cada una con su prop√≥sito. Las dos m√°s importantes para nosotros son:

üßµ La Pila (Stack)
üìç Qu√© es
La pila es una zona de memoria que funciona como una torre de cajas apiladas. Cada vez que llamas a una funci√≥n, el programa pone una caja en la cima de la pila.
Esa caja contiene:
    ‚Ä¢ Variables locales de la funci√≥n.
    ‚Ä¢ Los par√°metros que le pasaste a la funci√≥n.
    ‚Ä¢ La direcci√≥n a la que debe volver cuando la funci√≥n termine.

üöÄ C√≥mo funciona
    ‚Ä¢ Cada vez que llamas a una funci√≥n, se apila una caja nueva (stack frame).
    ‚Ä¢ Cuando la funci√≥n termina, esa caja se quita (desapila) autom√°ticamente.
    ‚Ä¢ No tienes que preocuparte por liberar esta memoria, lo hace el sistema solo.

‚úÖ Ventajas
‚úîÔ∏è S√∫per r√°pida (apilar y desapilar es instant√°neo).
‚úîÔ∏è Autom√°tica, no hay que hacer malloc ni free.
‚úîÔ∏è Ideal para variables temporales.

‚ö†Ô∏è Problemas
‚ùå La pila es peque√±a (normalmente unos 2-8 MB).
‚ùå Si intentas guardar algo gigante (como un array de 1 mill√≥n de enteros), te da un stack overflow.


üì¶ El Heap (Mont√≥n)
üìç Qu√© es
El heap es una zona mucho m√°s grande que la pila.
Es un almac√©n gigante y desordenado donde puedes pedir memoria din√°micamente usando malloc, calloc o realloc.

üöÄ C√≥mo funciona
    ‚Ä¢ Cuando llamas a malloc, el programa busca un trozo libre en el heap y te lo da.
    ‚Ä¢ Esa memoria no desaparece sola. Sigue existiendo hasta que t√∫ decidas liberarla con free.

‚úÖ Ventajas
‚úîÔ∏è Mucho m√°s grande que la pila (puedes pedir gigabytes).
‚úîÔ∏è Ideal para datos grandes o estructuras que deben sobrevivir entre funciones.

‚ö†Ô∏è Problemas
‚ùå M√°s lento que la pila (buscar espacio libre es caro).
‚ùå Si te olvidas de hacer free, creas un memory leak (fuga de memoria).
‚ùå Si liberas dos veces o accedes a memoria ya liberada, tienes un segmentation fault.

üßµ La pila es r√°pida y autom√°tica.
üì¶ El heap es grande pero manual.
üí£ Cada malloc sin free es un leak.
üí• Cada free doble es una bomba.

üìå ¬øQu√© es una variable est√°tica?
Una variable est√°tica en C se declara con la palabra clave static. La principal caracter√≠stica de estas variables es que su valor persiste entre las llamadas a una funci√≥n (a diferencia de las variables locales, que se reinician cada vez que la funci√≥n se llama).

üßµ Caracter√≠sticas de las variables est√°ticas
1. Persistencia de datos
Las variables est√°ticas conservan su valor incluso despu√©s de que la funci√≥n donde se declararon termine su ejecuci√≥n. Esto es diferente de las variables locales, que se destruyen cuando la funci√≥n termina.
2. Alcance limitado
Aunque las variables est√°ticas conservan su valor, solo son accesibles dentro de la funci√≥n donde se declaran (si son locales) o dentro del archivo (si son globales). Es decir, su alcance est√° limitado al bloque donde se encuentran, pero su valor persiste entre llamadas.
3. Ubicaci√≥n en memoria
Las variables est√°ticas se almacenan en una zona especial de memoria: el segmento de datos est√°ticos. Esto es diferente de las variables locales, que se almacenan en la pila.

üõ†Ô∏è ¬øCu√°ndo usar variables est√°ticas?
    ‚Ä¢ Contadores: Para mantener el estado entre m√∫ltiples invocaciones de una funci√≥n sin tener que pasar el valor por argumento o usar variables globales.
    ‚Ä¢ Memoria persistente: Cuando quieres que un valor persista, pero no quieres hacer que sea accesible globalmente.
    ‚Ä¢ Evitar errores por variables globales: Usar variables est√°ticas locales para evitar que la variable se manipule fuera de la funci√≥n y cause efectos secundarios inesperados.

üí° ¬øPor qu√© se usan las variables est√°ticas?
Las variables est√°ticas se usan para mantener el estado local a una funci√≥n sin tener que usar variables globales, lo que mejora la encapsulaci√≥n y evita posibles errores.
